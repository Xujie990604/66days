# 计算属性和监听器

## computed

* 你可以像绑定普通 property 一样在模板中绑定计算属性。
* Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。
* 而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。
* 减少模板中表达式的使用
* 当计算属性在模板中使用，并且计算属性的依赖值发现改变的时候就会触发他的更改(调用的是get函数)。如果不发生变化，使用的就是缓存的属性值。
* 如果计算属性直接被赋值的话，就会调用该属性的set函数，get和set函数不一定一起触发。只有符合条件才能被触发。
* 计算属性其实本质就是一个对象，只不过省略使用的话可以写成一个函数。所以使用计算属性的时候不需要加括号。
* 计算属性一般没有set方法，是一个只读属性。

### 计算属性和v-model配合使用的时候

* 计算属性如果想要和v-model配合使用的话，就必须同时具有get和set
* 由于绑定了v-model，所以在你改变input表单的数据时，就会自动触发input事件，这时你的v-model就会不断地接收的参数，(传参的这个过程不需要我们自己)

#### 一般的计算属性变量和v-model相配合

* 需要同时设置get和set，这是正常的逻辑

```js
  computed: {
    fullName: {
      // getter
      get () {
        return this.firstName + ' ' + this.lastName
      },
      // setter
      set(newValue) {
        var names = newValue.split(' ')
        this.firstName = names[0]
        this.lastName = names[names.length - 1]
      }
  }
};
```

#### 对象的计算属性和v-model相配合

* 这次遇到的需求是使用form时绑定一个对象的计算属性，里面的input绑定form对象里面的属性。刚开始我还以为要给这个对象变量同时设置get和set。可以后面根据计算属性的定义来说，根本就不需要了
* 计算属性是当get依赖的数据发生变化时，才会触发get，我的计算属性get依赖的属性是address，可是每次我在input中输入的时候更改的就不是address对象，更改的是address对象里面的属性，在vue里面直接更改对象的属性应该是不会触发响应式的，所以不需要使用set。

```js
// template的模板
// :model="editForm" 在v-model中使用了计算属性，不需要set方法的原因是，计算属性没有被改变(vue中对象的属性被改变应该不会触发响应式)
<el-form :model="editForm">
      <el-form-item label="姓名">
        <el-input
        // v-model="editForm.name" 尽管在v-model中，并且值被更改，可是它根本就不是计算属性。get和set方法都没有
          v-model="editForm.name"
          placeholder="请输入学生的姓名"
        ></el-input>
      </el-form-item>
      <el-form-item label="密码">
        <el-input
          v-model="editForm.password"
          placeholder="请输入学生的密码"
        ></el-input>
      </el-form-item>
      <el-form-item label="爱好">
        <el-input
          v-model="editForm.major.majorName"
          placeholder="请输入学生的爱好"
        ></el-input>
      </el-form-item>
</el-form>

// script的定义
    export default {
  name: "Edit",
  data() {
    return {
      address: {}
    };
  },
  computed: {
    editForm: {
      get() {
        // 从上一个路由接收的参数赋值给address
        this.address = this.$route.query.editForm;
        return this.address;
      }
    }
  },
```

#### set方法

* 如果是普通的变量需要调用set函数的时候，赋值形式为 this.fullName = "xu jie",不是像函数一样去传参
* 因为get的返回值是依赖data数据的，所以在使用set的时候也要依赖data中的数据。
* 如果set的函数改变了get函数的依赖项，那么计算属性的get函数就会被调用。

## 计算属性VS方法

* 计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。
* 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。

## 计算属性VS侦听属性

* 计算属性比较好
* 侦听属性适合在调试时使用

## 侦听器

* 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。