# 计算属性和监听器

## computed

* 你可以像绑定普通 property 一样在模板中绑定计算属性。
* Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。
* 而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。
* 减少模板中表达式的使用
* 当计算属性在模板中使用，并且计算属性的依赖值发现改变的时候就会触发他的更改(调用的是get函数)。如果不发生变化，使用的就是缓存的属性值。
* 如果计算属性直接被赋值的话，就会调用该属性的set函数，get和set函数不一定一起触发。只有符合条件才能被触发。
* 计算属性其实本质就是一个对象，只不过省略使用的话可以写成一个函数。所以使用计算属性的时候不需要加括号。
* 计算属性一般没有set方法，是一个只读属性。

### getter&setter

```javascript
  computed: {
    fullName: {
      // getter
      get: function () {
        return this.firstName + ' ' + this.lastName
      },
      // setter
      set: function (newValue) {
        var names = newValue.split(' ')
        this.firstName = names[0]
        this.lastName = names[names.length - 1]
      }
  }
};
```

* set方法也会进行响应式的触发

## 计算属性VS方法

* 计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。
* 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。

## 计算属性VS侦听属性

* 计算属性比较好
* 侦听属性适合在调试时使用

## 侦听器

* 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。