# 组件基础

## 组件构建的过程

* 使用Vue.extend()创建组件构造器 Vue2.x之后就很少显示的使用这个了，被合并到vue.component()这个过程中了
* 使用vue.component()来注册全局组件。如果是在某个Vue实例的component属性中进行注册的那么就是局部组件。
* 在实例的范围内进行使用。

## 组件的根实例的区别是拥有el选项

* new Vue创建的是Vue的根实例
* Vue.component注册的是全局组件
* 定义组件时，需要在父组件里面使用到的子组件要在父组件之前定义

## 组件的注册

### 组件命名规范

* 在DOM里面使用一个组件的时候。字母全部小写并且必须包含一个连字符
* 这会帮助你避免和现在的和未来的HTML元素相冲突
* 如果你在定义组件的时候命名为MyComponent的话，在引用这个组件的时候MyComponent和my-component都可以(在DOM中引入的情况除外)

### 全局注册

* 全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。
* 子组件之间也可以互相引用

```javascript
Vue.component('my-component-name', { /* 组件内容 */ })
```

* 可以直接把内容写在上文的组件内容部分，也可以使用模板分离的方式，使用template标签。

### 局部注册

* 像定义一个普通的js对象来定义组件
* 避免性能的浪费
* 局部注册需要在父组件中进行注册

```javascript
var ComponentA = { /* 组件内容 */ }
```

## 组件的data必须是一个函数

* 每使用一个组件，就会有一个新的实例被创建,因此每个实例都可以维护一份被返回对象独立的拷贝
* 否则就会影响到其他的复用组件的实例

## 父子组件传值

* 如果子组件声明了，父组件却没有传值过来的话，值为undefined
* 如果父组件给子组件传递的是引用类型数据的话，对象或者数组。可以不用注册事件，因为传递的是地址

### props传递数据

* attribute HTML标签上的属性， property Vue实例上的对象的属性
* 使用v-bind来动态的传递prop。然后子组件接收。就可以像data中的数据一样使用
* 在html通过v-bind传递props的时候，不可以使用驼峰标识，但是接收的时候可以。

#### prop的接收

* 字符串数组方式
* 对象方式，可以设置传递的类型和默认值等

#### prop的验证

* 基本的数据类型验证 Number String Object
* 多种可能的类型 propB:[String,Number]
* 必填的字段 propA：{type:String,required:true}
* 带有默认值的数字 PropA:{type:Number,default:100}
* 对象和数组的默认值必须从一个工厂函数来获取
* 还可以有自定义验证的函数
* prop会在组件的实例创建之前被验证，所以data，computed在props的default和验证函数里面是不可以使用的。

## attribute的替换/合并

* 对于绝大多数的attribute来说，从外部提供的值会替换组件内的值，例如type="text"
* 然而class和style会被合并

## 禁用attribute的继承

* 可以使得父组件向子组件传递的值，不被子组件的根组件继承为attribute

## 监听子组件的事件

* 子组件通过$emit("son-method",count)方法并传入事件名称来触发一个事件
* 自定义的事件没有event事件可以使用？？？
* 自定义的事件可以传递几个参数？？？
* 父级组件便可以像处理自己的DOM事件一样来监听子组件的事件。父组件通过$event来访问到这个值
* 如果父组件直接在内联样式处理子组件传递过来的参数使用$event，如果事件的处理函数是一个方法，会当做第一个参数传进去。
* 如果多层组件嵌套那就多层传递

## 自定义事件

* 事件不同于组件和prop，不存在任何的自动化大小写转换，需要完全匹配
* 不会识别对应的。kebab-case(小写字母，中划线的版本)
* 推荐始终使用 kebab-case 的事件名。

## 父子组件的访问方式

### $children

* 是一个数组，数组里面是Vue组件对象。
* 可以通过这个指令来访问子组件，并且访问子组件里面的属性。
* 比较少的使用

### $refs

* 是一个对象，子组件被当做key值来传进来
* 通过给子组件添加一个ref的方式来访问子组件。

### $parent

* 是一个数组，数组里面是Vue组件对象访问父组件
* 不推荐使用，这样的话组价就不独立了。

### $root

* 访问根组件，Vue实例

## 插槽

* 为了让组件更加的具有扩展性。
* 普通插槽如果想要使用变量的话，只能使用父级模板里面的内容。不能使用子模板里面的内容
* 后备内容：直接在子组件的插槽(slot)标签里面放置内容。如果父级没有传内容过来，默认显示，如果父级有东西传入，显示父级传入的内容。
* 使用新的语法v-slot标签可以实现父组件向子组件传入很多个template模块的内容

### 具名插槽

* 在子组件的slot标签上添加name特性
* 在父组件调用自组价时的标签上添加slot特性。

### 作用域插槽

* 在父组件的作用域内获取子组件的变量的值，用来插槽中。

```vue
<slot :data="books">
...子组件的slot插槽内定义属性,可以是data也可以是别的，所以可以
传递多个变量
</slot>

<component>
<!-- 父组件调用子组件时如何取到子组件的变量 -->
  <template slot-scope="slot">
    <span v-for="(item,index) in slot.data"></span>
  </template>
</component>
```

## 动态组件

```javascript
<component :is="myComponent"></component>
```

* is可以给普通HTML标签使用，但是标签就会被看做组件。组件的attribute行为，和HTML标签的attribute 行为有很大差别。

## 解析 DOM 模板时的注意事项

* 有些 HTML 元素，诸如 ul、ol、table 和 select，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 li、tr 和 option，只能出现在其它某些特定的元素内部。

```javascript
<table>
  <blog-post-row></blog-post-row>
</table>
```

这个自定义组件 (blog-post-row) 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is attribute 给了我们一个变通的办法：

```javascript
<table>
  <tr is="blog-post-row"></tr>
</table>
```
