# 组件基础

## 组件的根实例的区别是拥有el选项

* new Vue创建的是Vue的根实例
* Vue.component注册的是全局组件
* 定义组件时，需要在父组件里面使用到的子组件要在父组件之前定义

## 每使用一个组件，就会有一个新的实例被创建

* 子组件就可以被当做自定义组件来使用

## data必须是一个函数

* 因此每个实例都可以维护一份被返回对象独立的拷贝
* 否则就会影响到其他的复用组件的实例

## 组件的注册

### 组件命名规范

* 字母全部小写并且必须包含一个连字符
* 这会帮助你避免和现在的和未来的HTML元素相冲突

### 全局注册

* 全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。
* 子组件之间也可以互相引用

```javascript
Vue.component('my-component-name', { /* ... */ })
```

### 局部注册

* 避免性能的浪费
* 局部注册需要在父组件中进行注册

```javascript
var ComponentA = { /* ... */ }
```

## prop传递数据

* attribute HTML标签上的属性， property Vue实例上的对象的属性
* 使用v-bind来动态的传递prop。然后子组件接收。就可以像data中的数据一样使用

## 监听子组件的事件

* 子组件通过$emit("son-method",count)方法并传入事件名称来触发一个事件
* 父级组件便可以像处理自己的DOM事件一样来监听子组件的事件。父组件通过$event来访问到这个值
* 如果多层组件嵌套那就多层传递

## 自定义事件

* 事件不同于组件和prop，不存在任何的自动化大小写转换，需要完全匹配
* 不会识别对应的。kebab-case(小写字母，中划线的版本)
* 推荐始终使用 kebab-case 的事件名。

## 插槽

* 插槽如果想要使用变量的话，只能使用父级模板里面的内容。不能使用子模板里面的内容
* 后备内容：直接在子元素的插槽标签里面放置内容。如果父级没有传内容过来，默认显示，如果父级有东西传入，显示父级传入的内容。
* 使用新的语法v-slot标签可以实现父组件向子组件传入很多个template模块的内容

## 动态组件

```javascript
<component :is="myComponent"></component>
```

* is可以给普通HTML标签使用，但是标签就会被看做组件。组件的attribute行为，和HTML标签的attribute 行为有很大差别。

## 解析 DOM 模板时的注意事项

* 有些 HTML 元素，诸如 ul、ol、table 和 select，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 li、tr 和 option，只能出现在其它某些特定的元素内部。

```javascript
<table>
  <blog-post-row></blog-post-row>
</table>
```

这个自定义组件 (blog-post-row) 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is attribute 给了我们一个变通的办法：

```javascript
<table>
  <tr is="blog-post-row"></tr>
</table>
```
