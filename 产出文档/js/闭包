闭包: 当内部函数被保存到外部时，将会生成闭包，闭包会导致原有的作用域链不释放，造成内存泄漏（内存占用，剩的空间变少）。

-->实现公有变量    不依赖外部变量，而且能反复执行的累加器
-->可以做缓存（存储结构） 相当于一个仓库
-->可以实现封装，属性私有化
-->模块化开发，防止污染全局变量
function test () {
    var arr = [];
    for (var i = 0; i < 10; i++) {
        arr[i] = function () {
            document.write(i +" ");
        }
    }
    return arr;
}

var myArr = test();
for(var j = 0; j < 10; j++) {
    myArr[j]();
} 

输出结果：10 10 10 10 10 10 10 10 10 10

解析：这是一个闭包的问题 函数test内包含一个for循环，每个循环里都有一个函数表达式的赋值。
相当于是一个一对十的闭包。里面的是个函数表达式共用一个变量i。
！！！ arr[i] = function () {
            document.write(i +" ");
        }
函数定义的时候并不会被执行，比如这些代码的含义相当于
        arr[i] = 一个函数返回值
但是函数返回值是多少系统也并不知道。只有当这个函数执行之后才会知道函数的返回值是多少。
也就是说等 myArr[j]();这条语句执行完之后才会知道函数的返回值是多少。
因为for循环所以function test内的变量i累加到了10，才终止循环。
test函数执行完后，切断了test的执行期上下文，但是由于闭包的存在十个小函数依然保留着与test函数的执行期上下文的联系
因此等到十个内部函数执行时，每个函数都会读取出最后为10的i变量。

！！！解决方法 用闭包解决闭包问题 让一对十的闭包问题，转化为十对十的闭包问题。
function test () {
    var arr = [];
    for (var i = 0; i < 10; i++) {
       (function(j){
            arr[j] = function () {
            document.write(j +" ");
        }
       }(i))
    }
    return arr;
}

var myArr = test();
for(var j = 0; j < 10; j++) {
    myArr[j]();
} 
逗号运算符
(a,b)先运算前面的表达式，然后运算后面的表达式。最后输出后面的表达式



var x = 1;
if(function f() {}) {
    x += typeof f;
}
console.log(x);
输出：1undefined

if后面的()把里面的函数声明变成了表达式。因为函数声明不是那六个转换之后为false其中之一，所以if后面的语句可以执行。
并且函数名称f消失。typeof(f)为"undefined"
x += typeof f    1 + "undefined"   结果为 1undefined


