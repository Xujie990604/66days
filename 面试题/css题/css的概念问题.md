# css的相关试题

## css的盒模型

### 标准盒模型

* box-sizing: content-box;标准盒模型
* width和height 只是content内容的大小

### 代替盒模型

* box-sizing:border-box;混杂盒模型
* width 和 height 包含了内容区，内边距和边框

### width的百分值继承

* 盒模型中(无论是width height 还是 padding margin)使用百分数的时候，都是相对于父元素的真实的content区域的width和height大小。
* 如果在标准盒模型中就是width和height的大小，如果在怪异盒模型中，那就是width和height减去padding和border。

### 匿名盒子

* 有些内容没有被明确的包含在某个元素里面，但还是会有一个匿名块盒子。在屏幕上看到的一切都从属于某个盒子
* 开发者无法通过css来控制他们，能继承的属性会从父元素继承，不能继承的属性是默认值。

### 外边距折叠

* 发生的条件

1. 外边距折叠只发生在文档的常规文本流中的块级盒子的垂直方向上，行内盒子，浮动盒子，绝对定位的盒子不会发生内边距折叠。
2. 只要是常规文档中的盒子，外边距直接接触了(不论是兄弟元素还是父子元素，甚至是自己的上边距和下边距直接接触)都会发生外边距折叠

* 必要性

1. 因为外边距折叠的存在，无数的空段落也只会占用一小块的空间。

* 现象

1. 两个具有边距的元素上下相邻，两个盒子之间的边距大小是最大的那个单个边距大小。
2. 普通文档流中父子块级元素，如果父元素和子元素之间没有内边距和边框分割外边距(也就是说父子元素的外边距直接接触到了一起)，子元素的上边距就会和父元素的上边距重合，以他们两个中间最大上边距为准，与距离他们最近的盒子隔开。(属于设计的bug)

* 如何解决

1. 触发BFC
2. 不让外边距直接接触，无论是使用padding还是border

## BFC

### 如何触发BFC

* float 为 left,right
* overflow 的值为auto，hidden。
* display 的值为table-call，table-caption，inline-block，flex
* position 为 absolute,fixed

### BFC的特性

* 元素BFC化后，与浮动元素做兄弟，不会与浮动元素重叠
* 计算bfc元素的高度时，浮动元素也会参加运算，不需要再去清除浮动。(格式化上下文自动包含该浮动元素)。
* bfc就是一个独立的隔离容器，容器里面的子元素不会受到外面元素的影响

## 浮动

### 浮动的特性

1. 破坏性：设置了float属性的父元素会坍塌(因为和他结构上的父元素根本没在一层)；
2. 包裹性：设置了float属性的div元素会包裹(设置了浮动的div，不会自己占满一行)；不然后面的文字无法环绕它
3. 消空格： 脱离了文档流那么换行，空格啥的都不管用了。尽可能的去和其他浮动元素靠拢，浮动的几个图片之间没有一点间隔。
4. 当你的元素被设为 position：absolute； 和 float：left/right 时会从内部把元素转换为inline-block形式；

### 清除浮动

1. 如果只是想要兄弟元素不在围绕前面的浮动元素浮动时，就给兄弟加clear：both，清除浮动的原理是给下面的那个盒子加了一个足够大的上边距用来放置浮动元素，所以当清除元素后，在给下面的盒子添加上边距时，除非你添加的数值足够大，不然无法起作用。(最好是在上面的浮动盒子上添加margin-bottom来拉开距离)
2. 父元素清除浮动

```js
.clear-fix::after {
        content:"";
        clear:both;
        display:block;
}
```

## 定位

### 包含块

* absolute

1. 元素的包含块为最接近的父级元素具有position单不能是static
2. 如果都没有显示的定义position，那么元素的包含块是浏览器窗口(不是body是(html标签的父级))

* fixed

1. 元素的包含块为浏览器窗口。

### 层叠上下文

* 需要z-index触发创建层叠上下文 position 值为 relative/absolute/fixed  flex 项(父元素 display 为 flex|inline-flex)，注意是子元素，不是父元素创建层叠上下文
* 不需要z-index触发创建层叠上下文 元素的透明度 opacity 小于1 transform不是none

### z-index

* 同为神奇盒子的父元素如果没有显示的声明z-index(或者显式的声明为auto)，子元素的z-index值小于零的话，子元素就会到父元素的底下。
* 只要是父元素显式的声明了z-index的话，无论子元素的z-index的值多小，子元素也不会到父元素的底下。
* z-Index是在自己的父级内的层叠顺序，和伯伯元素的层叠顺序建立在父级和伯伯元素的层叠顺序上。

* 具有层叠的顺序的盒子和普通盒子的视轴顺序
* HTML > z-Index为负值的盒子 > 块状盒子 > float盒子 > inline,inline-block > z-Index为auto或者0的盒子 > z-Index为正值的盒子

## 伪类选择器都有哪些

1. :focus input:focus 伪类选择器 选择获得焦点的 input 元素。
2. :first-child (p:first-child) p元素的父元素的第一个子元素并且是p元素。
3. :last-child (p:last-child) p元素的父元素的倒数第一个子元素并且是p元素。
4. :nth-child(n) (p:nth-child(2)) 选择属于其父元素的第二个子元素，并且是p元素 even 偶数 odd 奇数 2n + 1 n从零开始
5. :nth-last-child(n) (:nth-last-child(2)) 选择属于其父元素的倒数第二个子元素，并且是p元素
6. :first-of-type (p:first-of-type) 选择属于其父元素的首个p元素
7. :last-of-type (p:last-of-type) 选择属于其父元素的最后一个p元素
8. :nth-of-type(n) (p:nth-of-type(2)) 选择属于其父元素第二个p元素
9. :nth-last-of-type(n) p:nth-last-of-type(2) 选择属于其父元素倒数第二个p元素
10. :not(selector) :not(p) 选择非p元素的每个元素。(可以连续使用) li:not(.a)选择li中类名不带有a的li。
11. :enable  :disabled  :checked 表单的伪类有很多
12. :root 根文档选择器

## 负边距

* 在文档流中，元素的最终边界是由margin来决定的，margin为负的时候相当于元素的边界往里面收。视觉效果不变，文档流中DOM变小。
* 左边或上边的负边距会把元素自身向左或者向上拉，盖住其旁边的元素。
* 右边或下边的负边距会把相邻元素向左或者向上拉，盖住设置了负边距的元素。
* (可视区域不会变).而与浮动方向相同的负边距会在该方向上把浮动的元素向外平移,自身覆盖其他元素。在浮动的元素上，与浮动方向相反的负边距会导致元素被其他元素覆盖。
* 给未声明宽度的(非浮动块级元素)使用负边距时，左右负边距会向外拉伸元素，导致元素扩张，有可能盖住相邻元素。

## 权重

* 256进制相加 p.header就是10+1=11

1. ！important             无穷大
2. 行间样式                 1000
3. id选择器                 100
4. 类选择器|属性|伪类        10
5. 标签|伪元素               1
6. 通配符                    0
7. 继承                     没有权重

### 状态伪类的顺序

* :link : visited :hover :active
* 因为他们都是伪类选择器，后面的选择器会覆盖前面的样式，所以按照状态的先后顺序来书写

## 继承

* 继承的权重比零还小，是无。
* a标签的字体颜色不能继承，h1-h6的字体大小不能继承。因为有默认值。

## em rem px

* px就是一个绝对的长度单位

### em

* 在font-size中使用em时。1em就是从父元素那里继承过来的大小，并且使用em会有多次继承问题
* 在盒模型尺寸中使用em时，1em就是当前元素的font-size的大小。

### rem

* 是基于html的font-size的大小
* 在:root中设置的font-size就是rem的大小

## 图片

### 置换元素/替换元素

* 图片，视频，框架
* 他们本身有自己的高度和宽度。而且有自己的比例。
* 设置属性max-width：100%；会保证图片不会超过父元素的情况下，也不会超过自己的最大宽度，不会模糊
* 当替换元素成为网格或者flex布局的一部分时，他们不会被拉伸以适应容器，尽量给替换元素一个外包装类。让外包装类进行拉伸。

### object-fit属性

* fill  在必要时拉伸图片以填满容器 破坏宽高比
* content 尽可能的让图片最大化，浏览器会选择一个方向100%，另一个方向auto。保留长宽比
* cover 让图片占满区域  保留长宽比，但是会有一部分被切割掉
* none 会采用图片固有大小

## Flex布局

### flex属性

* auto：从width和height那里获得尺寸，如果没有规定那么就根据内容来分配大小。
* 0 ：不在这一步获取内容的基础大小，直接到系数哪里分配大小。basic为0的话，width属性的设置也会不起作用。使用flex的属性比width的优先级要高，不考虑书写的顺序。max-width和min-width的优先级在flex全部分配完之后。

* 默认值flex: 0 1 auto;
* flex: 0;代表 flex: 1 1 0;

* 在一定的flex容器中，直接给一个子项margin： auto；直接垂直居中