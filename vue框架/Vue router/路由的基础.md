# 路由

* 路由是网络工程里面的术语
* 路由就是通过互联网的网络把信息从源地址传输到目的地址的活动

## 映射表

* 路由表的本质上就是一个映射表，决定了数据包的指向。

## 前端渲染后端渲染

### 后端的渲染(服务端渲染)

* 原来的话后端使用jsp写页面，html+css+java java代码就直接从数据库中读取数据，并且将它动态的放在页面上
* 以前的网页是没有ajax技术的。整个页面都是重新获取的
* 浏览器输入RUL，直接将RUL发送给后端，后端直接返回页面
* 后端路由就是由后端处理URL和页面之间的映射关系
* 后端渲染直接交给客户端展示的话，有利于SEO的优化。
* 结构样式和数据全都糅合在一起，编写和维护都是很恶心的。

### 前后端分离的阶段

* 随着ajax的出现
* 后端只负责提供数据，不负责任何页面的功能
* 后端就是一个提供API接口的服务器
* 在浏览器输入URL的话，去静态服务器下载html+css+js，html和css浏览器能够直接的渲染到页面，然后执行js代码，根据ajax去后端服务器请求数据，然后再根据请求到的数据增删改查DOM和CSS，然后再将新的页面渲染到页面上。
* 根据不同的URl下载不同的html+css+js，静态服务器中存在很多套html+css+js
* 这个阶段叫做前端渲染
* 前后端任务的分离，后端负责数据，前端负责交互和可视化

#### 单页面(spa)富应用阶段

* 在前后端分离的基础上加上了一层前端路由
* 静态资源服务器上只有一套html+css+js，在获取的时候会一次性获得所有文件，只不过不全部显示
* 然后根据不同的URL，从获取的html+css+js中抽离对应的部分(在vue中也就是对应的组件)
* 页面和URl的映射关系由前端路由来管理
* 改变URL的时候，页面是不进行整体的刷新的

## 如何改变URL而不刷新页面

* hash
* html5的history模式，类似是栈的模式

## 安装和使用

* npm install vue-router --save因为在运行时也需要路由插件

### 使用

* 导入路由对象，并且调用Vue.use(VueRouter),Vue.use()是安装的意思，任何插件在使用前都需要在Vue中安装一下。执行完Vue.use(VueRouter)之后内部自动执行VueRouter.install()
* 创建路由实例并且导出，并且配置路由映射
* 在Vue实例中挂载导入的路由实例
* 在模块化开发的时候，如果是一个目录，默认会去找文件夹下的index文件
* router-link是vue-router里面注册的组件，全局组件。不需要导入就可以使用。最终就会被渲染为a标签
* router-view是路由最终被显示到哪里

## VueRouter源码的解析

* 所有的组件都继承自Vue类的原型
* 所以在main.js中在Vue的原型链上定义属性或者方法的话，每个Vue组件都可以拿到这个属性或者方法。

## router-link

* 给router-link添加一个tag特性，就可以指定router-link会被渲染成什么
* to属性，源码里面使用的是pushState()会留下痕迹
* replace属性，添加replace属性之后，路由的跳转就不会留下痕迹。
* 默认情况下，被选中的router-link都会被添加一个类名，也可以去router的实例里面添加一个linkActiveClass的属性，用来修改默认添加的类名。

## $router属性

* vue-router给每一个组件都添加了$router的属性
* 通过this.$router可以访问到路由对象实例(this指代当前的组件)
* $router取到的就是router实例(和main.js文件里面引用的那个vueRouter是同一个)(用来使用路由变换的方法)。$route取到的是当前活跃的某个路由对象(可以用来取动态路由的参数)。

## 脚手架打包dist

* js文件会分成几份，app.js是当前应用程序的所有业务代码  vender.js是提供商，第三方的文件(例如Vue/vue-router/axios) manifest.js为了打包的代码做底层的支撑
* 要是使用了路由懒加载的话，有几个懒加载的路由就会在dist文件中多几个js文件

## 路由的懒加载

* 为了下载js代码的时候快速一点，刚开始只加载用到的，以后也是加载用到的组件。
* 路由的懒加载就是将路由对应的组件打包成一个个js的代码块。只有在这个路由被访问到时，才加载对应的组价。
* () => import('../components/cpn.vue')

## 路由的嵌套

* 第一层路由需要在前面加/(例如/home)，第一层路由下的子路由不需要加/(例如URL:/home/homeNews 写成'homeNews')
* 使用children属性来定义嵌套路由 在路由的配置文件里路径名不必自己写嵌套路径，根据children属性就可以有层级关系
* 但是在使用router.push()跳转的时候需要进行手动的路径嵌套，用于匹配映射表
* 匹配空路由，在有children的路由中设置一个空的指向子路由(最好使用路由重定向，路由重定向，也是默认子路由的一种方法)

## 导航守卫

* 参数的查询或查询的改变并不会触发进入/离开的导航卫士。
* 导航：路由的变化称之为导航
* 守卫：这些方法称之为守卫

### meta元数据

* 如果想要在不同的路由下浏览器页面有不同的标题，就在路由映射表里面定义meta对象。然后通过to来访问即将进入的路由对象，
* 称每个路由对象为路由记录
* 一个路由匹配到的所有路由记录都会被暴露到$route.match()数组

### 全局守卫

* router.beforeEach((to,from,next) => {...})
* to 即将要进入的目标路由对象
* from 当前导航要离开的路由对象
* next 调用方法执行的钩子函数
    1. next(false)中断当前的导航，重置到from
    2. next()执行管道中的下一个钩子函数，如果全部钩子执行完了，那么导航的状态就是confirmed
    3. next('/login'),当前的导航被中断，进行一个新的导航
    4. next(error)导航终止并且错误会被传递到router.onError()注册过的回调
* next()只能被严格调用一次，

* afterEach()全局后置的钩子函数，不需要主动调用next()函数
* 在导航被确认之前，同时所有的组件内守卫和异步路由组件被解析之后，调用。

### 路由独享的守卫

* 在映射表进行属性的配置
* beforeEnter()在进入路由前的守卫

### 组件内的守卫

#### beforeRouteEnter()

* 在渲染该组件的对应路由被confirm之前，调用
* 不能获取this实例，因为当前组件的实例还没有被创建
* 可以给next()传递回调，通过vm来访问组件实例

#### beforeRouteUpdate()

* 在当前路由被改变，但是组件被复用时调用
* 可以访问实例this

#### beforeRouteLeave()

* 在导航离开组件的时候调用
* 通常用来禁用用户还未保留修改就离开，改导航可以使用next(false)来取消
* 可以使用实例this

## keep-alive与router的邂逅

* keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。
* 可以让keep-alive内部的组件在路由的切换时不被重新创建和销毁。也就是会保留组件内部的状态。

### activated和deactivated

* 在当前组件活跃和失活的时候被调用
* 这两个状态只有在组件被keep-alive包含时才有效。

### include和exclude属性

* 可以指定哪些组件被保持状态，哪些组件不被保持状态
* 添加的是组件的name，这个name终于被用到了
* 还可以使用正则