# 缓存

## webpack的缓存

* 为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。
* 不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制

## 浏览器的缓存

### Expires和Cache-Control字段

* Cache-Control的优先级高于Expires
* Expires是http1.0的字段

* Cache-Control是HTTP1.1的字段

  1. public：所有内容都将被缓存（客户端和代理服务器都可缓存）
  2. private：所有内容只有客户端可以缓存，Cache-Control的默认取值
  3. no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
  4. no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
  5. max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

### 内存缓存和硬盘缓存

内存缓存(from memory cache)

  1. 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。
  2. 时效性：一旦该进程关闭，则该进程的内存则会清空。

硬盘缓存(from disk cache)

  1. 硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。

在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)

### 强制缓存和协商缓存

强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。

**和强制缓存有关的字段是Expires和Cache-Control**

1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求
2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存
3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

**和协商缓存有关的是Last-Modified / If-Modified-Since和Etag / If-None-Match**

  1. 携带缓存标识发起请求，如果资源没有更新，返回304，协商缓存生效
  2. 携带缓存标识发起请求， 资源有更新，返回200，协商缓存失效

* 强制缓存优先于协商缓存，强制缓存由本地的缓存结果决定是否生效，协商缓存由服务器决定决定是否生效。