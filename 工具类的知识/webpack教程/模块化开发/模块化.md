# 模块化

## 为什么会有模块化开发

* 解决变量命名冲突的问题
* 以前使用立即执行函数或者使用对象来解决这种问题，但是使用立即执行函数的话，函数外面的js语句无法使用立即执行函数内的变量和方法。需要使用return来返回一个对象。(ES5的模块化)

## 模块化的规范

* 核心都是导出和导入

### CommonJs规范(了解)(常见于node环境)

#### 导出

```js
// 在上面正常的定义变量和函数
// 在下面导出需要的变量和函数
module.exports = {
    flag,
    sum
    // 使用的是对象字面量的增强写法
}
```

#### 导入

```js
使用解构赋值的方式进行引用
var { flag, sum } = require('./script.js')

```

#### 特点

* commonJs规范是同步的加载，会出现浏览器假死的问题。

### ES6的模块化

* 给每个script加上一个type="module"时，每个js文件就会有自己的作用域

#### ES6导出

```js
export { flag , sum }
export { flag as a  , sum as b }

// 也可以在定义的时候直接导出(函数，变量，类都可以)
export let flag = false;

// export default 被导出之后，使用者可以自己起名字应用。
// 但是每个模块只能导出一个东西
// 并且导入的时候不能使用{}
// export default a = {}的形式是错的。使用default的意思就是，把default后面的变量赋值为default，应该直接export default {...}
export default address;
import addr from './aaa.js'
```

#### ES6导入

```js
import { flag , sum } from './script.js';
import { flag as a  , sum as b } from './script.js';

// 统一将所有的东西导入
// 把所有的东西按照变成一个对象导入
import * as aaa from './aaa.js'
console.log(aaa.flag)
```